// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/tauri-apps/gir-files)
// DO NOT EDIT

use glib::translate::*;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "JSCCheckSyntaxMode")]
pub enum CheckSyntaxMode {
  #[doc(alias = "JSC_CHECK_SYNTAX_MODE_SCRIPT")]
  Script,
  #[doc(alias = "JSC_CHECK_SYNTAX_MODE_MODULE")]
  Module,
  #[doc(hidden)]
  __Unknown(i32),
}

impl fmt::Display for CheckSyntaxMode {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    write!(
      f,
      "CheckSyntaxMode::{}",
      match *self {
        Self::Script => "Script",
        Self::Module => "Module",
        _ => "Unknown",
      }
    )
  }
}

#[doc(hidden)]
impl IntoGlib for CheckSyntaxMode {
  type GlibType = ffi::JSCCheckSyntaxMode;

  fn into_glib(self) -> ffi::JSCCheckSyntaxMode {
    match self {
      Self::Script => ffi::JSC_CHECK_SYNTAX_MODE_SCRIPT,
      Self::Module => ffi::JSC_CHECK_SYNTAX_MODE_MODULE,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::JSCCheckSyntaxMode> for CheckSyntaxMode {
  unsafe fn from_glib(value: ffi::JSCCheckSyntaxMode) -> Self {
    match value {
      ffi::JSC_CHECK_SYNTAX_MODE_SCRIPT => Self::Script,
      ffi::JSC_CHECK_SYNTAX_MODE_MODULE => Self::Module,
      value => Self::__Unknown(value),
    }
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "JSCCheckSyntaxResult")]
pub enum CheckSyntaxResult {
  #[doc(alias = "JSC_CHECK_SYNTAX_RESULT_SUCCESS")]
  Success,
  #[doc(alias = "JSC_CHECK_SYNTAX_RESULT_RECOVERABLE_ERROR")]
  RecoverableError,
  #[doc(alias = "JSC_CHECK_SYNTAX_RESULT_IRRECOVERABLE_ERROR")]
  IrrecoverableError,
  #[doc(alias = "JSC_CHECK_SYNTAX_RESULT_UNTERMINATED_LITERAL_ERROR")]
  UnterminatedLiteralError,
  #[doc(alias = "JSC_CHECK_SYNTAX_RESULT_OUT_OF_MEMORY_ERROR")]
  OutOfMemoryError,
  #[doc(alias = "JSC_CHECK_SYNTAX_RESULT_STACK_OVERFLOW_ERROR")]
  StackOverflowError,
  #[doc(hidden)]
  __Unknown(i32),
}

impl fmt::Display for CheckSyntaxResult {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    write!(
      f,
      "CheckSyntaxResult::{}",
      match *self {
        Self::Success => "Success",
        Self::RecoverableError => "RecoverableError",
        Self::IrrecoverableError => "IrrecoverableError",
        Self::UnterminatedLiteralError => "UnterminatedLiteralError",
        Self::OutOfMemoryError => "OutOfMemoryError",
        Self::StackOverflowError => "StackOverflowError",
        _ => "Unknown",
      }
    )
  }
}

#[doc(hidden)]
impl IntoGlib for CheckSyntaxResult {
  type GlibType = ffi::JSCCheckSyntaxResult;

  fn into_glib(self) -> ffi::JSCCheckSyntaxResult {
    match self {
      Self::Success => ffi::JSC_CHECK_SYNTAX_RESULT_SUCCESS,
      Self::RecoverableError => ffi::JSC_CHECK_SYNTAX_RESULT_RECOVERABLE_ERROR,
      Self::IrrecoverableError => ffi::JSC_CHECK_SYNTAX_RESULT_IRRECOVERABLE_ERROR,
      Self::UnterminatedLiteralError => ffi::JSC_CHECK_SYNTAX_RESULT_UNTERMINATED_LITERAL_ERROR,
      Self::OutOfMemoryError => ffi::JSC_CHECK_SYNTAX_RESULT_OUT_OF_MEMORY_ERROR,
      Self::StackOverflowError => ffi::JSC_CHECK_SYNTAX_RESULT_STACK_OVERFLOW_ERROR,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::JSCCheckSyntaxResult> for CheckSyntaxResult {
  unsafe fn from_glib(value: ffi::JSCCheckSyntaxResult) -> Self {
    match value {
      ffi::JSC_CHECK_SYNTAX_RESULT_SUCCESS => Self::Success,
      ffi::JSC_CHECK_SYNTAX_RESULT_RECOVERABLE_ERROR => Self::RecoverableError,
      ffi::JSC_CHECK_SYNTAX_RESULT_IRRECOVERABLE_ERROR => Self::IrrecoverableError,
      ffi::JSC_CHECK_SYNTAX_RESULT_UNTERMINATED_LITERAL_ERROR => Self::UnterminatedLiteralError,
      ffi::JSC_CHECK_SYNTAX_RESULT_OUT_OF_MEMORY_ERROR => Self::OutOfMemoryError,
      ffi::JSC_CHECK_SYNTAX_RESULT_STACK_OVERFLOW_ERROR => Self::StackOverflowError,
      value => Self::__Unknown(value),
    }
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "JSCOptionType")]
pub enum OptionType {
  #[doc(alias = "JSC_OPTION_BOOLEAN")]
  Boolean,
  #[doc(alias = "JSC_OPTION_INT")]
  Int,
  #[doc(alias = "JSC_OPTION_UINT")]
  Uint,
  #[doc(alias = "JSC_OPTION_SIZE")]
  Size,
  #[doc(alias = "JSC_OPTION_DOUBLE")]
  Double,
  #[doc(alias = "JSC_OPTION_STRING")]
  String,
  #[doc(alias = "JSC_OPTION_RANGE_STRING")]
  RangeString,
  #[doc(hidden)]
  __Unknown(i32),
}

impl fmt::Display for OptionType {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    write!(
      f,
      "OptionType::{}",
      match *self {
        Self::Boolean => "Boolean",
        Self::Int => "Int",
        Self::Uint => "Uint",
        Self::Size => "Size",
        Self::Double => "Double",
        Self::String => "String",
        Self::RangeString => "RangeString",
        _ => "Unknown",
      }
    )
  }
}

#[doc(hidden)]
impl IntoGlib for OptionType {
  type GlibType = ffi::JSCOptionType;

  fn into_glib(self) -> ffi::JSCOptionType {
    match self {
      Self::Boolean => ffi::JSC_OPTION_BOOLEAN,
      Self::Int => ffi::JSC_OPTION_INT,
      Self::Uint => ffi::JSC_OPTION_UINT,
      Self::Size => ffi::JSC_OPTION_SIZE,
      Self::Double => ffi::JSC_OPTION_DOUBLE,
      Self::String => ffi::JSC_OPTION_STRING,
      Self::RangeString => ffi::JSC_OPTION_RANGE_STRING,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::JSCOptionType> for OptionType {
  unsafe fn from_glib(value: ffi::JSCOptionType) -> Self {
    match value {
      ffi::JSC_OPTION_BOOLEAN => Self::Boolean,
      ffi::JSC_OPTION_INT => Self::Int,
      ffi::JSC_OPTION_UINT => Self::Uint,
      ffi::JSC_OPTION_SIZE => Self::Size,
      ffi::JSC_OPTION_DOUBLE => Self::Double,
      ffi::JSC_OPTION_STRING => Self::String,
      ffi::JSC_OPTION_RANGE_STRING => Self::RangeString,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(any(feature = "v2_38", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_38")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "JSCTypedArrayType")]
pub enum TypedArrayType {
  #[doc(alias = "JSC_TYPED_ARRAY_NONE")]
  None,
  #[doc(alias = "JSC_TYPED_ARRAY_INT8")]
  Int8,
  #[doc(alias = "JSC_TYPED_ARRAY_INT16")]
  Int16,
  #[doc(alias = "JSC_TYPED_ARRAY_INT32")]
  Int32,
  #[doc(alias = "JSC_TYPED_ARRAY_INT64")]
  Int64,
  #[doc(alias = "JSC_TYPED_ARRAY_UINT8")]
  Uint8,
  #[doc(alias = "JSC_TYPED_ARRAY_UINT8_CLAMPED")]
  Uint8Clamped,
  #[doc(alias = "JSC_TYPED_ARRAY_UINT16")]
  Uint16,
  #[doc(alias = "JSC_TYPED_ARRAY_UINT32")]
  Uint32,
  #[doc(alias = "JSC_TYPED_ARRAY_UINT64")]
  Uint64,
  #[doc(alias = "JSC_TYPED_ARRAY_FLOAT32")]
  Float32,
  #[doc(alias = "JSC_TYPED_ARRAY_FLOAT64")]
  Float64,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(any(feature = "v2_38", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_38")))]
impl fmt::Display for TypedArrayType {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    write!(
      f,
      "TypedArrayType::{}",
      match *self {
        Self::None => "None",
        Self::Int8 => "Int8",
        Self::Int16 => "Int16",
        Self::Int32 => "Int32",
        Self::Int64 => "Int64",
        Self::Uint8 => "Uint8",
        Self::Uint8Clamped => "Uint8Clamped",
        Self::Uint16 => "Uint16",
        Self::Uint32 => "Uint32",
        Self::Uint64 => "Uint64",
        Self::Float32 => "Float32",
        Self::Float64 => "Float64",
        _ => "Unknown",
      }
    )
  }
}

#[cfg(any(feature = "v2_38", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_38")))]
#[doc(hidden)]
impl IntoGlib for TypedArrayType {
  type GlibType = ffi::JSCTypedArrayType;

  fn into_glib(self) -> ffi::JSCTypedArrayType {
    match self {
      Self::None => ffi::JSC_TYPED_ARRAY_NONE,
      Self::Int8 => ffi::JSC_TYPED_ARRAY_INT8,
      Self::Int16 => ffi::JSC_TYPED_ARRAY_INT16,
      Self::Int32 => ffi::JSC_TYPED_ARRAY_INT32,
      Self::Int64 => ffi::JSC_TYPED_ARRAY_INT64,
      Self::Uint8 => ffi::JSC_TYPED_ARRAY_UINT8,
      Self::Uint8Clamped => ffi::JSC_TYPED_ARRAY_UINT8_CLAMPED,
      Self::Uint16 => ffi::JSC_TYPED_ARRAY_UINT16,
      Self::Uint32 => ffi::JSC_TYPED_ARRAY_UINT32,
      Self::Uint64 => ffi::JSC_TYPED_ARRAY_UINT64,
      Self::Float32 => ffi::JSC_TYPED_ARRAY_FLOAT32,
      Self::Float64 => ffi::JSC_TYPED_ARRAY_FLOAT64,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(any(feature = "v2_38", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_38")))]
#[doc(hidden)]
impl FromGlib<ffi::JSCTypedArrayType> for TypedArrayType {
  unsafe fn from_glib(value: ffi::JSCTypedArrayType) -> Self {
    match value {
      ffi::JSC_TYPED_ARRAY_NONE => Self::None,
      ffi::JSC_TYPED_ARRAY_INT8 => Self::Int8,
      ffi::JSC_TYPED_ARRAY_INT16 => Self::Int16,
      ffi::JSC_TYPED_ARRAY_INT32 => Self::Int32,
      ffi::JSC_TYPED_ARRAY_INT64 => Self::Int64,
      ffi::JSC_TYPED_ARRAY_UINT8 => Self::Uint8,
      ffi::JSC_TYPED_ARRAY_UINT8_CLAMPED => Self::Uint8Clamped,
      ffi::JSC_TYPED_ARRAY_UINT16 => Self::Uint16,
      ffi::JSC_TYPED_ARRAY_UINT32 => Self::Uint32,
      ffi::JSC_TYPED_ARRAY_UINT64 => Self::Uint64,
      ffi::JSC_TYPED_ARRAY_FLOAT32 => Self::Float32,
      ffi::JSC_TYPED_ARRAY_FLOAT64 => Self::Float64,
      value => Self::__Unknown(value),
    }
  }
}
