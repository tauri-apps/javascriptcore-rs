// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/wusyong/gir-files)
// DO NOT EDIT

use glib::translate::*;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "JSCCheckSyntaxMode")]
pub enum CheckSyntaxMode {
  #[doc(alias = "JSC_CHECK_SYNTAX_MODE_SCRIPT")]
  Script,
  #[doc(alias = "JSC_CHECK_SYNTAX_MODE_MODULE")]
  Module,
  #[doc(hidden)]
  __Unknown(i32),
}

impl fmt::Display for CheckSyntaxMode {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    write!(
      f,
      "CheckSyntaxMode::{}",
      match *self {
        Self::Script => "Script",
        Self::Module => "Module",
        _ => "Unknown",
      }
    )
  }
}

#[doc(hidden)]
impl IntoGlib for CheckSyntaxMode {
  type GlibType = ffi::JSCCheckSyntaxMode;

  fn into_glib(self) -> ffi::JSCCheckSyntaxMode {
    match self {
      Self::Script => ffi::JSC_CHECK_SYNTAX_MODE_SCRIPT,
      Self::Module => ffi::JSC_CHECK_SYNTAX_MODE_MODULE,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::JSCCheckSyntaxMode> for CheckSyntaxMode {
  unsafe fn from_glib(value: ffi::JSCCheckSyntaxMode) -> Self {
    match value {
      ffi::JSC_CHECK_SYNTAX_MODE_SCRIPT => Self::Script,
      ffi::JSC_CHECK_SYNTAX_MODE_MODULE => Self::Module,
      value => Self::__Unknown(value),
    }
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "JSCCheckSyntaxResult")]
pub enum CheckSyntaxResult {
  #[doc(alias = "JSC_CHECK_SYNTAX_RESULT_SUCCESS")]
  Success,
  #[doc(alias = "JSC_CHECK_SYNTAX_RESULT_RECOVERABLE_ERROR")]
  RecoverableError,
  #[doc(alias = "JSC_CHECK_SYNTAX_RESULT_IRRECOVERABLE_ERROR")]
  IrrecoverableError,
  #[doc(alias = "JSC_CHECK_SYNTAX_RESULT_UNTERMINATED_LITERAL_ERROR")]
  UnterminatedLiteralError,
  #[doc(alias = "JSC_CHECK_SYNTAX_RESULT_OUT_OF_MEMORY_ERROR")]
  OutOfMemoryError,
  #[doc(alias = "JSC_CHECK_SYNTAX_RESULT_STACK_OVERFLOW_ERROR")]
  StackOverflowError,
  #[doc(hidden)]
  __Unknown(i32),
}

impl fmt::Display for CheckSyntaxResult {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    write!(
      f,
      "CheckSyntaxResult::{}",
      match *self {
        Self::Success => "Success",
        Self::RecoverableError => "RecoverableError",
        Self::IrrecoverableError => "IrrecoverableError",
        Self::UnterminatedLiteralError => "UnterminatedLiteralError",
        Self::OutOfMemoryError => "OutOfMemoryError",
        Self::StackOverflowError => "StackOverflowError",
        _ => "Unknown",
      }
    )
  }
}

#[doc(hidden)]
impl IntoGlib for CheckSyntaxResult {
  type GlibType = ffi::JSCCheckSyntaxResult;

  fn into_glib(self) -> ffi::JSCCheckSyntaxResult {
    match self {
      Self::Success => ffi::JSC_CHECK_SYNTAX_RESULT_SUCCESS,
      Self::RecoverableError => ffi::JSC_CHECK_SYNTAX_RESULT_RECOVERABLE_ERROR,
      Self::IrrecoverableError => ffi::JSC_CHECK_SYNTAX_RESULT_IRRECOVERABLE_ERROR,
      Self::UnterminatedLiteralError => ffi::JSC_CHECK_SYNTAX_RESULT_UNTERMINATED_LITERAL_ERROR,
      Self::OutOfMemoryError => ffi::JSC_CHECK_SYNTAX_RESULT_OUT_OF_MEMORY_ERROR,
      Self::StackOverflowError => ffi::JSC_CHECK_SYNTAX_RESULT_STACK_OVERFLOW_ERROR,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::JSCCheckSyntaxResult> for CheckSyntaxResult {
  unsafe fn from_glib(value: ffi::JSCCheckSyntaxResult) -> Self {
    match value {
      ffi::JSC_CHECK_SYNTAX_RESULT_SUCCESS => Self::Success,
      ffi::JSC_CHECK_SYNTAX_RESULT_RECOVERABLE_ERROR => Self::RecoverableError,
      ffi::JSC_CHECK_SYNTAX_RESULT_IRRECOVERABLE_ERROR => Self::IrrecoverableError,
      ffi::JSC_CHECK_SYNTAX_RESULT_UNTERMINATED_LITERAL_ERROR => Self::UnterminatedLiteralError,
      ffi::JSC_CHECK_SYNTAX_RESULT_OUT_OF_MEMORY_ERROR => Self::OutOfMemoryError,
      ffi::JSC_CHECK_SYNTAX_RESULT_STACK_OVERFLOW_ERROR => Self::StackOverflowError,
      value => Self::__Unknown(value),
    }
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "JSCOptionType")]
pub enum OptionType {
  #[doc(alias = "JSC_OPTION_BOOLEAN")]
  Boolean,
  #[doc(alias = "JSC_OPTION_INT")]
  Int,
  #[doc(alias = "JSC_OPTION_UINT")]
  Uint,
  #[doc(alias = "JSC_OPTION_SIZE")]
  Size,
  #[doc(alias = "JSC_OPTION_DOUBLE")]
  Double,
  #[doc(alias = "JSC_OPTION_STRING")]
  String,
  #[doc(alias = "JSC_OPTION_RANGE_STRING")]
  RangeString,
  #[doc(hidden)]
  __Unknown(i32),
}

impl fmt::Display for OptionType {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    write!(
      f,
      "OptionType::{}",
      match *self {
        Self::Boolean => "Boolean",
        Self::Int => "Int",
        Self::Uint => "Uint",
        Self::Size => "Size",
        Self::Double => "Double",
        Self::String => "String",
        Self::RangeString => "RangeString",
        _ => "Unknown",
      }
    )
  }
}

#[doc(hidden)]
impl IntoGlib for OptionType {
  type GlibType = ffi::JSCOptionType;

  fn into_glib(self) -> ffi::JSCOptionType {
    match self {
      Self::Boolean => ffi::JSC_OPTION_BOOLEAN,
      Self::Int => ffi::JSC_OPTION_INT,
      Self::Uint => ffi::JSC_OPTION_UINT,
      Self::Size => ffi::JSC_OPTION_SIZE,
      Self::Double => ffi::JSC_OPTION_DOUBLE,
      Self::String => ffi::JSC_OPTION_STRING,
      Self::RangeString => ffi::JSC_OPTION_RANGE_STRING,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::JSCOptionType> for OptionType {
  unsafe fn from_glib(value: ffi::JSCOptionType) -> Self {
    match value {
      ffi::JSC_OPTION_BOOLEAN => Self::Boolean,
      ffi::JSC_OPTION_INT => Self::Int,
      ffi::JSC_OPTION_UINT => Self::Uint,
      ffi::JSC_OPTION_SIZE => Self::Size,
      ffi::JSC_OPTION_DOUBLE => Self::Double,
      ffi::JSC_OPTION_STRING => Self::String,
      ffi::JSC_OPTION_RANGE_STRING => Self::RangeString,
      value => Self::__Unknown(value),
    }
  }
}
