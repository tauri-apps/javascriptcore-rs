// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/vhdirk/gir-files)
// DO NOT EDIT

use crate::{Context, ValuePropertyFlags};
use glib::{
  object::{Cast, IsA},
  translate::*,
  StaticType, ToValue,
};
use std::fmt;

glib::wrapper! {
    #[doc(alias = "JSCValue")]
    pub struct Value(Object<ffi::JSCValue, ffi::JSCValueClass>);

    match fn {
        type_ => || ffi::jsc_value_get_type(),
    }
}

impl Value {
  //#[doc(alias = "jsc_value_new_array")]
  //pub fn new_array(context: &impl IsA<Context>, first_item_type: glib::types::Type, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Value {
  //    unsafe { TODO: call ffi:jsc_value_new_array() }
  //}

  #[doc(alias = "jsc_value_new_array_from_garray")]
  pub fn new_array_from_garray(context: &impl IsA<Context>, array: &[Value]) -> Value {
    unsafe {
      from_glib_full(ffi::jsc_value_new_array_from_garray(
        context.as_ref().to_glib_none().0,
        array.to_glib_none().0,
      ))
    }
  }

  #[doc(alias = "jsc_value_new_array_from_strv")]
  pub fn new_array_from_strv(context: &impl IsA<Context>, strv: &[&str]) -> Value {
    unsafe {
      from_glib_full(ffi::jsc_value_new_array_from_strv(
        context.as_ref().to_glib_none().0,
        strv.to_glib_none().0,
      ))
    }
  }

  #[doc(alias = "jsc_value_new_boolean")]
  pub fn new_boolean(context: &impl IsA<Context>, value: bool) -> Value {
    unsafe {
      from_glib_full(ffi::jsc_value_new_boolean(
        context.as_ref().to_glib_none().0,
        value.into_glib(),
      ))
    }
  }

  #[cfg(any(feature = "v2_28", feature = "dox"))]
  #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
  #[doc(alias = "jsc_value_new_from_json")]
  #[doc(alias = "new_from_json")]
  pub fn from_json(context: &impl IsA<Context>, json: &str) -> Value {
    unsafe {
      from_glib_full(ffi::jsc_value_new_from_json(
        context.as_ref().to_glib_none().0,
        json.to_glib_none().0,
      ))
    }
  }

  //#[doc(alias = "jsc_value_new_function")]
  //pub fn new_function<P: Fn() + 'static>(context: &impl IsA<Context>, name: Option<&str>, callback: P, user_data: /*Unimplemented*/Option<Fundamental: Pointer>, return_type: glib::types::Type, n_params: u32, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Value {
  //    unsafe { TODO: call ffi:jsc_value_new_function() }
  //}

  //#[doc(alias = "jsc_value_new_function_variadic")]
  //pub fn new_function_variadic(context: &impl IsA<Context>, name: Option<&str>, callback: /*Unimplemented*/Fn(/*Ignored*/glib::PtrArray) -> Value, user_data: /*Unimplemented*/Option<Fundamental: Pointer>, return_type: glib::types::Type) -> Value {
  //    unsafe { TODO: call ffi:jsc_value_new_function_variadic() }
  //}

  //#[doc(alias = "jsc_value_new_functionv")]
  //pub fn new_functionv<P: Fn() + 'static>(context: &impl IsA<Context>, name: Option<&str>, callback: P, user_data: /*Unimplemented*/Option<Fundamental: Pointer>, return_type: glib::types::Type, n_parameters: u32) -> Value {
  //    unsafe { TODO: call ffi:jsc_value_new_functionv() }
  //}

  #[doc(alias = "jsc_value_new_null")]
  pub fn new_null(context: &impl IsA<Context>) -> Value {
    unsafe { from_glib_full(ffi::jsc_value_new_null(context.as_ref().to_glib_none().0)) }
  }

  #[doc(alias = "jsc_value_new_number")]
  pub fn new_number(context: &impl IsA<Context>, number: f64) -> Value {
    unsafe {
      from_glib_full(ffi::jsc_value_new_number(
        context.as_ref().to_glib_none().0,
        number,
      ))
    }
  }

  //#[doc(alias = "jsc_value_new_object")]
  //pub fn new_object(context: &impl IsA<Context>, instance: /*Unimplemented*/Option<Fundamental: Pointer>, jsc_class: Option<&Class>) -> Value {
  //    unsafe { TODO: call ffi:jsc_value_new_object() }
  //}

  #[doc(alias = "jsc_value_new_string")]
  pub fn new_string(context: &impl IsA<Context>, string: Option<&str>) -> Value {
    unsafe {
      from_glib_full(ffi::jsc_value_new_string(
        context.as_ref().to_glib_none().0,
        string.to_glib_none().0,
      ))
    }
  }

  #[doc(alias = "jsc_value_new_string_from_bytes")]
  pub fn new_string_from_bytes(context: &impl IsA<Context>, bytes: Option<&glib::Bytes>) -> Value {
    unsafe {
      from_glib_full(ffi::jsc_value_new_string_from_bytes(
        context.as_ref().to_glib_none().0,
        bytes.to_glib_none().0,
      ))
    }
  }

  #[doc(alias = "jsc_value_new_undefined")]
  pub fn new_undefined(context: &impl IsA<Context>) -> Value {
    unsafe {
      from_glib_full(ffi::jsc_value_new_undefined(
        context.as_ref().to_glib_none().0,
      ))
    }
  }

  // rustdoc-stripper-ignore-next
  /// Creates a new builder-pattern struct instance to construct [`Value`] objects.
  ///
  /// This method returns an instance of [`ValueBuilder`] which can be used to create [`Value`] objects.
  pub fn builder() -> ValueBuilder {
    ValueBuilder::default()
  }
}

impl fmt::Display for Value {
  #[inline]
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    f.write_str(&ValueExt::to_str(self))
  }
}

#[derive(Clone, Default)]
// rustdoc-stripper-ignore-next
/// A [builder-pattern] type to construct [`Value`] objects.
///
/// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
pub struct ValueBuilder {
  context: Option<Context>,
}

impl ValueBuilder {
  // rustdoc-stripper-ignore-next
  /// Create a new [`ValueBuilder`].
  pub fn new() -> Self {
    Self::default()
  }

  // rustdoc-stripper-ignore-next
  /// Build the [`Value`].
  pub fn build(self) -> Value {
    let mut properties: Vec<(&str, &dyn ToValue)> = vec![];
    if let Some(ref context) = self.context {
      properties.push(("context", context));
    }
    glib::Object::new::<Value>(&properties).expect("Failed to create an instance of Value")
  }

  pub fn context(mut self, context: &impl IsA<Context>) -> Self {
    self.context = Some(context.clone().upcast());
    self
  }
}

pub const NONE_VALUE: Option<&Value> = None;

pub trait ValueExt: 'static {
  //#[doc(alias = "jsc_value_constructor_call")]
  //fn constructor_call(&self, first_parameter_type: glib::types::Type, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<Value>;

  #[doc(alias = "jsc_value_constructor_callv")]
  fn constructor_callv(&self, parameters: &[Value]) -> Option<Value>;

  //#[doc(alias = "jsc_value_function_call")]
  //fn function_call(&self, first_parameter_type: glib::types::Type, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<Value>;

  #[doc(alias = "jsc_value_function_callv")]
  fn function_callv(&self, parameters: &[Value]) -> Option<Value>;

  #[doc(alias = "jsc_value_get_context")]
  #[doc(alias = "get_context")]
  fn context(&self) -> Option<Context>;

  #[doc(alias = "jsc_value_is_array")]
  fn is_array(&self) -> bool;

  #[doc(alias = "jsc_value_is_boolean")]
  fn is_boolean(&self) -> bool;

  #[doc(alias = "jsc_value_is_constructor")]
  fn is_constructor(&self) -> bool;

  #[doc(alias = "jsc_value_is_function")]
  fn is_function(&self) -> bool;

  #[doc(alias = "jsc_value_is_null")]
  fn is_null(&self) -> bool;

  #[doc(alias = "jsc_value_is_number")]
  fn is_number(&self) -> bool;

  #[doc(alias = "jsc_value_is_object")]
  fn is_object(&self) -> bool;

  #[doc(alias = "jsc_value_is_string")]
  fn is_string(&self) -> bool;

  #[doc(alias = "jsc_value_is_undefined")]
  fn is_undefined(&self) -> bool;

  #[doc(alias = "jsc_value_object_define_property_data")]
  fn object_define_property_data(
    &self,
    property_name: &str,
    flags: ValuePropertyFlags,
    property_value: Option<&impl IsA<Value>>,
  );

  #[doc(alias = "jsc_value_object_delete_property")]
  fn object_delete_property(&self, name: &str) -> bool;

  #[doc(alias = "jsc_value_object_enumerate_properties")]
  fn object_enumerate_properties(&self) -> Vec<glib::GString>;

  #[doc(alias = "jsc_value_object_get_property")]
  fn object_get_property(&self, name: &str) -> Option<Value>;

  #[doc(alias = "jsc_value_object_get_property_at_index")]
  fn object_get_property_at_index(&self, index: u32) -> Option<Value>;

  #[doc(alias = "jsc_value_object_has_property")]
  fn object_has_property(&self, name: &str) -> bool;

  //#[doc(alias = "jsc_value_object_invoke_method")]
  //fn object_invoke_method(&self, name: &str, first_parameter_type: glib::types::Type, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<Value>;

  #[doc(alias = "jsc_value_object_invoke_methodv")]
  fn object_invoke_methodv(&self, name: &str, parameters: &[Value]) -> Option<Value>;

  #[doc(alias = "jsc_value_object_is_instance_of")]
  fn object_is_instance_of(&self, name: &str) -> bool;

  #[doc(alias = "jsc_value_object_set_property")]
  fn object_set_property(&self, name: &str, property: &impl IsA<Value>);

  #[doc(alias = "jsc_value_object_set_property_at_index")]
  fn object_set_property_at_index(&self, index: u32, property: &impl IsA<Value>);

  #[doc(alias = "jsc_value_to_boolean")]
  fn to_boolean(&self) -> bool;

  #[doc(alias = "jsc_value_to_double")]
  fn to_double(&self) -> f64;

  #[doc(alias = "jsc_value_to_int32")]
  fn to_int32(&self) -> i32;

  #[cfg(any(feature = "v2_28", feature = "dox"))]
  #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
  #[doc(alias = "jsc_value_to_json")]
  fn to_json(&self, indent: u32) -> Option<glib::GString>;

  #[doc(alias = "jsc_value_to_string")]
  #[doc(alias = "to_string")]
  fn to_str(&self) -> glib::GString;

  #[doc(alias = "jsc_value_to_string_as_bytes")]
  fn to_string_as_bytes(&self) -> Option<glib::Bytes>;
}

impl<O: IsA<Value>> ValueExt for O {
  //fn constructor_call(&self, first_parameter_type: glib::types::Type, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<Value> {
  //    unsafe { TODO: call ffi:jsc_value_constructor_call() }
  //}

  fn constructor_callv(&self, parameters: &[Value]) -> Option<Value> {
    let n_parameters = parameters.len() as u32;
    unsafe {
      from_glib_full(ffi::jsc_value_constructor_callv(
        self.as_ref().to_glib_none().0,
        n_parameters,
        parameters.to_glib_none().0,
      ))
    }
  }

  //fn function_call(&self, first_parameter_type: glib::types::Type, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<Value> {
  //    unsafe { TODO: call ffi:jsc_value_function_call() }
  //}

  fn function_callv(&self, parameters: &[Value]) -> Option<Value> {
    let n_parameters = parameters.len() as u32;
    unsafe {
      from_glib_full(ffi::jsc_value_function_callv(
        self.as_ref().to_glib_none().0,
        n_parameters,
        parameters.to_glib_none().0,
      ))
    }
  }

  fn context(&self) -> Option<Context> {
    unsafe { from_glib_none(ffi::jsc_value_get_context(self.as_ref().to_glib_none().0)) }
  }

  fn is_array(&self) -> bool {
    unsafe { from_glib(ffi::jsc_value_is_array(self.as_ref().to_glib_none().0)) }
  }

  fn is_boolean(&self) -> bool {
    unsafe { from_glib(ffi::jsc_value_is_boolean(self.as_ref().to_glib_none().0)) }
  }

  fn is_constructor(&self) -> bool {
    unsafe {
      from_glib(ffi::jsc_value_is_constructor(
        self.as_ref().to_glib_none().0,
      ))
    }
  }

  fn is_function(&self) -> bool {
    unsafe { from_glib(ffi::jsc_value_is_function(self.as_ref().to_glib_none().0)) }
  }

  fn is_null(&self) -> bool {
    unsafe { from_glib(ffi::jsc_value_is_null(self.as_ref().to_glib_none().0)) }
  }

  fn is_number(&self) -> bool {
    unsafe { from_glib(ffi::jsc_value_is_number(self.as_ref().to_glib_none().0)) }
  }

  fn is_object(&self) -> bool {
    unsafe { from_glib(ffi::jsc_value_is_object(self.as_ref().to_glib_none().0)) }
  }

  fn is_string(&self) -> bool {
    unsafe { from_glib(ffi::jsc_value_is_string(self.as_ref().to_glib_none().0)) }
  }

  fn is_undefined(&self) -> bool {
    unsafe { from_glib(ffi::jsc_value_is_undefined(self.as_ref().to_glib_none().0)) }
  }

  fn object_define_property_data(
    &self,
    property_name: &str,
    flags: ValuePropertyFlags,
    property_value: Option<&impl IsA<Value>>,
  ) {
    unsafe {
      ffi::jsc_value_object_define_property_data(
        self.as_ref().to_glib_none().0,
        property_name.to_glib_none().0,
        flags.into_glib(),
        property_value.map(|p| p.as_ref()).to_glib_none().0,
      );
    }
  }

  fn object_delete_property(&self, name: &str) -> bool {
    unsafe {
      from_glib(ffi::jsc_value_object_delete_property(
        self.as_ref().to_glib_none().0,
        name.to_glib_none().0,
      ))
    }
  }

  fn object_enumerate_properties(&self) -> Vec<glib::GString> {
    unsafe {
      FromGlibPtrContainer::from_glib_full(ffi::jsc_value_object_enumerate_properties(
        self.as_ref().to_glib_none().0,
      ))
    }
  }

  fn object_get_property(&self, name: &str) -> Option<Value> {
    unsafe {
      from_glib_full(ffi::jsc_value_object_get_property(
        self.as_ref().to_glib_none().0,
        name.to_glib_none().0,
      ))
    }
  }

  fn object_get_property_at_index(&self, index: u32) -> Option<Value> {
    unsafe {
      from_glib_full(ffi::jsc_value_object_get_property_at_index(
        self.as_ref().to_glib_none().0,
        index,
      ))
    }
  }

  fn object_has_property(&self, name: &str) -> bool {
    unsafe {
      from_glib(ffi::jsc_value_object_has_property(
        self.as_ref().to_glib_none().0,
        name.to_glib_none().0,
      ))
    }
  }

  //fn object_invoke_method(&self, name: &str, first_parameter_type: glib::types::Type, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<Value> {
  //    unsafe { TODO: call ffi:jsc_value_object_invoke_method() }
  //}

  fn object_invoke_methodv(&self, name: &str, parameters: &[Value]) -> Option<Value> {
    let n_parameters = parameters.len() as u32;
    unsafe {
      from_glib_full(ffi::jsc_value_object_invoke_methodv(
        self.as_ref().to_glib_none().0,
        name.to_glib_none().0,
        n_parameters,
        parameters.to_glib_none().0,
      ))
    }
  }

  fn object_is_instance_of(&self, name: &str) -> bool {
    unsafe {
      from_glib(ffi::jsc_value_object_is_instance_of(
        self.as_ref().to_glib_none().0,
        name.to_glib_none().0,
      ))
    }
  }

  fn object_set_property(&self, name: &str, property: &impl IsA<Value>) {
    unsafe {
      ffi::jsc_value_object_set_property(
        self.as_ref().to_glib_none().0,
        name.to_glib_none().0,
        property.as_ref().to_glib_none().0,
      );
    }
  }

  fn object_set_property_at_index(&self, index: u32, property: &impl IsA<Value>) {
    unsafe {
      ffi::jsc_value_object_set_property_at_index(
        self.as_ref().to_glib_none().0,
        index,
        property.as_ref().to_glib_none().0,
      );
    }
  }

  fn to_boolean(&self) -> bool {
    unsafe { from_glib(ffi::jsc_value_to_boolean(self.as_ref().to_glib_none().0)) }
  }

  fn to_double(&self) -> f64 {
    unsafe { ffi::jsc_value_to_double(self.as_ref().to_glib_none().0) }
  }

  fn to_int32(&self) -> i32 {
    unsafe { ffi::jsc_value_to_int32(self.as_ref().to_glib_none().0) }
  }

  #[cfg(any(feature = "v2_28", feature = "dox"))]
  #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
  fn to_json(&self, indent: u32) -> Option<glib::GString> {
    unsafe {
      from_glib_full(ffi::jsc_value_to_json(
        self.as_ref().to_glib_none().0,
        indent,
      ))
    }
  }

  fn to_str(&self) -> glib::GString {
    unsafe { from_glib_full(ffi::jsc_value_to_string(self.as_ref().to_glib_none().0)) }
  }

  fn to_string_as_bytes(&self) -> Option<glib::Bytes> {
    unsafe {
      from_glib_full(ffi::jsc_value_to_string_as_bytes(
        self.as_ref().to_glib_none().0,
      ))
    }
  }
}
